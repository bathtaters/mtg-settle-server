mixin typedInp(key, inpType, limits, defaultValue, classes)
  if isNaN(inpType)
    input(
      name=key id=key class=classes readonly=(inpType === 'readonly')
      value=defaultValue
      type=(inpType === 'id' ? "number" : inpType === 'readonly' ? "text" : inpType)
      step=(inpType === 'number' ? "any" : inpType === 'id' ? "1" : undefined)
      pattern=(inpType === 'number' || inpType === 'id' ? "\\d+" : undefined)
      min=(limits && (inpType === 'number' || inpType === 'id') ? limits.min : inpType === 'id' ? "0" : undefined)
      max=(limits && (inpType === 'number' || inpType === 'id') ? limits.max : undefined)
      minLength=(limits && (inpType === 'text' || inpType === 'password') ? limits.min : undefined)
      maxLength=(limits && (inpType === 'text' || inpType === 'password') ? limits.max : undefined)
      autocomplete=(inpType === 'password' ? 'new-password' : key === 'username' ? 'username' : undefined)
    )
    if (inpType === 'password')
      button.toggle-password.small(type="button")
  else
    textarea(name=key id=key class=classes rows=inpType)= defaultValue

mixin formInput(key, inpType, limits, defaultValue, label, classes, tooltip)
  if inpType === 'hidden'
    +typedInp(key, inpType, null, defaultValue, "hidden")
  else
    .input-group.vertical
      label(for=key aria-label=tooltip class=(tooltip ? 'tooltip' : ''))= label || varName(key)
      +typedInp(key, inpType, limits, defaultValue, classes)

mixin checkboxes(key, options, label)
  fieldset.input-group.vertical
    legend= label || varName(key)
    each item in options
      .input-group
        input.accessChecks(type='checkbox' name=key id=item value=item)
        label(for=item)= item

mixin buttonInput(key, inpType, button, limits, defaultValue, label, tooltip, buttonKey = 'action')
  .input-group.vertical.button-input
    label(for=key aria-label=tooltip class=(tooltip ? 'tooltip' : ''))= label || varName(key)
    .button-group
      +typedInp(key, inpType, limits, defaultValue)
      input.button(type='button' name=buttonKey id=buttonKey+button value=button)

mixin buttonRow(buttons, classes = [], key = 'action', buttonType = 'submit')
  .row.button-group
    each action, idx in buttons
      input.large(
        type=buttonType name=key id=key+action value=action
        class=((classes[idx] && classes[idx].replace('disabled','').trim()) || 'inverse')
        disabled=(!!classes[idx] && classes[idx].includes('disabled'))
      )

mixin pageData(page, size, id = 'queryString', pageKey = 'page', sizeKey = 'size')
  if (page || size)
    - var qryStr = `?${pageKey}=${page || 1}` + (size ? `&${sizeKey}=${size}` : '')
    +formInput(id, 'hidden', null, qryStr)

mixin pageNav(page, size, total, sizes, prev = '<', next = '>', pageKey = 'page', sizeKey = 'size')
  .row.center

    if (total > 1)
      .col.row.center
        if prev
          a.button(href=(page > 1 && `?${pageKey}=${page - 1}&${sizeKey}=${size}`) disabled=(page < 2))= prev

        -var p = 0
        while p++ < total
          a.button.solid(href=(p !== page && `?${pageKey}=${p}&${sizeKey}=${size}`) disabled=(p === page) class=(p === page ? 'inverse' : ''))= p

        if next
          a.button(href=(page < total && `?${pageKey}=${page + 1}&${sizeKey}=${size}`) disabled=(page >= total))= next

    if (total > 1 && sizes && sizes.length > 1)
      .marginX

    if (sizes && sizes.length > 1)
      .col.row
        .col.center.marginX Page size:
        each opt in sizes
          a.button.solid(href=(size !== opt && `?${pageKey}=1&${sizeKey}=${opt}`) disabled=(size === opt) class=(size === opt ? 'inverse' : ''))= opt